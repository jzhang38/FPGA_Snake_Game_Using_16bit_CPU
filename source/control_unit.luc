module control_unit (
    input clk,
    input irq, 
    input z,
    input reset,    
    input opcode[6],
    output pcsel[3], 
    output wasel,
    output asel,
    output ra2sel,
    output bsel,
    output alufn[6],
    output wdsel[2], 
    output werf,
    output moe, 
    output xwr,
    output random_write
  ) {
  
  const CU_ROM = { b000000001111001100,//this instruction is illegal in beta, but I use it to control the random number generator
    b000000110001101100,
    b000000110000101100,
    b000000110000001100,
    b011100000000000100,
    b000000101011001100,
    b000000101111001100, 
    b000000101100001100,
    b011100000000000100,
    b000000111011101100,
    b000000111010101100,
    b000000111001101100,
    b011100000000000100,
    b011100000000000100,
    b000000100000101100,
    b000000100000001100,  
    b011100000000000100,
    b000000010001101100,
    b000000010000101100, 
    b000000010000001100,
    b011100000000000100,
    b000000001011001100,
    b000000001111001100,
    b000000001100001100, 
    b011100000000000100, 
    b000000011011101100,
    b000000011010101100,
    b000000001111001100,//this instruction is JMP in beta, but I change it to my special instruction: RAND(generate random number and store in either R25 or R26)
    b011100000000000100, 
    b011100000000000100,
    b000000000000101100,
    b000000000000001100,
    b000010001101010110,
    b000010001101000100,
    b000010001101000100,
    b011100000000000100,
    b010010001101000100,
    b011100000000000100,
    b000001100000000001,
    b000000100000010110,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100,
    b011100000000000100};
    
  dff irq_sampler(#INIT(0), .clk(clk));

  always {
  
    irq_sampler.d = irq;
  
    pcsel = CU_ROM[opcode][17:15]; 
    wasel = CU_ROM[opcode][14]; 
    asel = CU_ROM[opcode][13]; 
    ra2sel = CU_ROM[opcode][12]; 
    bsel = CU_ROM[opcode][11]; 
    alufn = CU_ROM[opcode][10:5]; 
    wdsel = CU_ROM[opcode][4:3];  
    werf= CU_ROM[opcode][2]; 
    moe = CU_ROM[opcode][1]; 
    xwr = CU_ROM[opcode][0]; 
    random_write = 0;
    if (opcode == 6b011011){
      werf = 1;
      random_write = 1;
    }
    
    // beq bne handling 
    if (opcode == b011101 && z == 1){//BEQ, branch if z == 1
      pcsel = b001;
    }
    else if (opcode == b011110 && z == 0){ //BNE, branch if z != 1
      pcsel = b001;
    }
    
    // force xwr = 0 when reset == 1 
    if (reset){
      xwr = 0;
      werf = 0;
    }
    
    // interrupt checker, will overwrite everything hence we put at the bottom    
    if (irq_sampler.q == 1){
      pcsel = b100;
      wasel = 1;
      werf = 1;
      wdsel = b00;
      xwr = 0;
    }
    
    

  }
}
